//
//  MatchDetailsInteractor.swift
//  Brasileirao
//
//  Created by Fabio Martinez on 08/01/2019.
//  Copyright (c) 2018 Fabio Martinez. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MatchDetailsBusinessLogic
{
    func getTitle(request: MatchDetails.GetTitle.Request)
    func getBids(request: MatchDetails.FetchBids.Request)
    func loadingTimerInvalidate(request: MatchDetails.FetchBids.Request)
    func getDataSource(request: MatchDetails.FetchBids.Request.Loading)
}

protocol MatchDetailsDataStore
{
  var match: Match! { get set }
}

class MatchDetailsInteractor: MatchDetailsDataStore {
      
    var match: Match!
    var loadingTimer: Timer?
    
    var presenter: MatchDetailsPresentationLogic?
    var worker = MatchDetailsWorker()

    
}

extension MatchDetailsInteractor: MatchDetailsBusinessLogic {
    
    func getTitle(request: MatchDetails.GetTitle.Request) {
        let response = MatchDetails.GetTitle.Response(match: match)
        presenter?.presentTitle(response: response)
    }
    
    func getBids(request: MatchDetails.FetchBids.Request) {
        if let matchResumeUrl = match.transmission?.url {
            configWaitingMsg()
            worker.fetchBids(url: matchResumeUrl, completionHandler: { [weak self] result in
                guard let weakSelf = self else { return }
                weakSelf.loadingTimer?.invalidate()
                if let bids = result as? [Bid] {
                    //escondo msg de loading
                    weakSelf.presenter?.presentHideMessage(response: MatchDetails.FetchBids.Response.HideMessage())
                    var dataSource = weakSelf.initMatchDataSource(withLoading: false, match: weakSelf.match)
                    for bid in bids {
                        dataSource.append(MatchDetailsItemType.bidItem(bid: bid))
                    }
                    let response = MatchDetails.FetchBids.Response.Succes(dataSource: dataSource)
                    weakSelf.presenter?.presentDataSource(response: response)
                } else if let error = result as? Error {
                    let response = MatchDetails.FetchBids.Response.Error(message: error.localizedDescription)
                    weakSelf.presenter?.presentErrorOnFetch(response: response)
                    let request = MatchDetails.FetchBids.Request.Loading(isLoading: false)
                    weakSelf.getDataSource(request: request)
                }
            })
        }

    }
    
    func loadingTimerInvalidate(request: MatchDetails.FetchBids.Request) {
        loadingTimer?.invalidate()
    }
    
    func getDataSource(request: MatchDetails.FetchBids.Request.Loading) {
        let response = MatchDetails.FetchBids.Response.Succes(dataSource: initMatchDataSource(withLoading: request.isLoading, match: match))
        presenter?.presentDataSource(response: response)
    }
    
    private func configWaitingMsg() {
        //usado para disparar o showWaitingMsg pq a api do heroku na primeira chamada demora muito para responder
        //pq a maquina pode estar off
        loadingTimer = Timer.scheduledTimer(timeInterval: 6, target: self, selector: (#selector(self.showWaitingMsg)), userInfo: nil, repeats: true)
    }
    
    private func hideMessage() {
        let response = MatchDetails.FetchBids.Response.HideMessage()
        presenter?.presentHideMessage(response: response)
    }
    
    @objc private func showWaitingMsg() {
        let options = ["Estamos carregando ainda...", "Lembra que essa api ta no heroku!", "Só mais um pouco...", "Paciência é uma virtude!", "O tempo é um processo de espera!"]
        let waitingMessageResponse = MatchDetails.FetchBids.Response.WaitingMessage(message: options.randomElement()!)
        presenter?.presentWaitingMessage(response: waitingMessageResponse)

    }
    
    private func initMatchDataSource(withLoading: Bool, match: Match) -> ([MatchDetailsItemType]) {
        var dataSource = [MatchDetailsItemType]()
        dataSource.append(MatchDetailsItemType.matchItem(match: match))
        dataSource.append(MatchDetailsItemType.bidToBidItem)
        if withLoading == true {
            dataSource.append(MatchDetailsItemType.loadingItem)
        }
        return dataSource
    }

}
